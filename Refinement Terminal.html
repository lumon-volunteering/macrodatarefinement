<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Macrodata Refinement UI – Dranesville</title>
  <link rel="stylesheet" href="refinement.css">
</head>

<body>
  <div id="pageWrapper">
    <img id="sticky1" src="sticky1.png" alt="sticky1">
    <img id="sticky2" src="sticky2.png" alt="sticky2">
    <img id="screenOverlay" src="overlay.png" alt="screenOverlay">
      <div id="appContainer" class="crt">

        <div id="bouncingGlobeOverlay">
          <!-- Example globe SVG – replace with your actual globeSvg if needed -->
          <svg id="globeSvg" width="300" height="150" viewBox="-4 -4 308 158">
            <g class="glow">
              <ellipse cx="150" cy="75" rx="150" ry="75" fill="none" stroke="#8ef1fa" stroke-width="4"/>
              <line x1="30" y1="30" x2="270" y2="30" stroke="#8ef1fa" stroke-width="4"/>
              <line x1="30" y1="120" x2="270" y2="120" stroke="#8ef1fa" stroke-width="4"/>
              <path d="M 150,0 A 60,75 0 0 1 150,150" fill="none" stroke="#8ef1fa" stroke-width="4"/>
              <path d="M 150,0 A 100,75 0 0 1 150,150" fill="none" stroke="#8ef1fa" stroke-width="4"/>
              <path d="M 150,0 A 100,75 0 0 0 150,150" fill="none" stroke="#8ef1fa" stroke-width="4"/>
              <path d="M 150,0 A 60,75 0 0 0 150,150" fill="none" stroke="#8ef1fa" stroke-width="4"/>
            </g>
              <rect x="40" y="45" width="220" height="60" fill="#001C2E" stroke="none" filter="none"!important/>
            </svg>
        </div>

        <div id="mainContainer">
          <!-- Wrap all UI elements (except background and CRT filter) in uiContainer for fade-in -->
            <!-- Top progress area -->
            <div id="totalProgressContainer">
              <div id="titleBox">
                <div id="globeContainer">
                  <svg width="300" height="150" viewBox="-4 -4 308 158">
                      <ellipse cx="150" cy="75" rx="150" ry="75" fill="#001C2E" stroke="#8ef1fa" stroke-width="4"/>
                      <line x1="30" y1="30" x2="270" y2="30" stroke="#8ef1fa" stroke-width="4"/>
                      <line x1="30" y1="120" x2="270" y2="120" stroke="#8ef1fa" stroke-width="4"/>
                      <path d="M 150,0 A 60,75 0 0 1 150,150" fill="none" stroke="#8ef1fa" stroke-width="4"/>
                      <path d="M 150,0 A 100,75 0 0 1 150,150" fill="none" stroke="#8ef1fa" stroke-width="4"/>
                      <path d="M 150,0 A 100,75 0 0 0 150,150" fill="none" stroke="#8ef1fa" stroke-width="4"/>
                      <path d="M 150,0 A 60,75 0 0 0 150,150" fill="none" stroke="#8ef1fa" stroke-width="4"/>
                      <rect x="40" y="45" width="220" height="60" fill="#001C2E" stroke="none"/>
                  </svg>
                  <div id="totalProgressText">0% Complete</div>
                </div>
                <div id="totalProgressName">Pathfinder</div>
                <div id="totalProgressFill"></div>
                <div id="progressBlocker"></div>
              </div>
            </div>

            <!-- Top separator -->
            <div id="topSeparator" class="separator">
              <div class="line"></div>
              <div class="line"></div>
            </div>
            
            <!-- Canvas container for digit grid -->
            <div id="canvasContainer">
              <canvas id="gridCanvas"></canvas>
            </div>
            
            <!-- Bottom separator -->
            <div id="bottomSeparator" class="separator">
              <div class="line"></div>
              <div class="line"></div>
            </div>
            
            <!-- Bins container -->
            <div id="binsContainer">
              <div class="binContainer">
                <div class="bin" data-bin="01">01
                  <div class="lid left"></div>
                  <div class="lid right"></div>
                  <div class="lid-duplicate left"></div>
                  <div class="lid-duplicate right"></div>
                </div>
                <div class="binProgress" data-bin="01">
                  <div class="binProgressTextContainer">
                    <span class="binProgressText back">0%</span>
                    <span class="binProgressText front">0%</span>
                  </div>
                  <div class="binProgressFill"></div>
                </div>
                <div class="binChart" data-bin="01">
                  <div class="chartHeader">01</div>
                  <div class="chartRow" data-temper="WO">
                    <div class="label" style="color:#8DD571; text-shadow:0 0 8px #fff;">WO</div>
                    <div class="bar" style="border: 3px solid #8DD571;" ><div class="fill" style="background:#8DD571; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="FC">
                    <div class="label" style="color:#F2D230; text-shadow:0 0 8px #fff;">FC</div>
                    <div class="bar" style="border: 3px solid #F2D230;" ><div class="fill" style="background:#F2D230; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="DR">
                    <div class="label" style="color:#F9A09F; text-shadow:0 0 8px #fff;">DR</div>
                    <div class="bar" style="border: 3px solid #F9A09F;" ><div class="fill" style="background:#F9A09F; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="MA">
                    <div class="label" style="color:#047FFD; text-shadow:0 0 8px #fff;">MA</div>
                    <div class="bar" style="border: 3px solid #047FFD;" ><div class="fill" style="background:#047FFD; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                </div>
              </div>
              
              <div class="binContainer">
                <div class="bin" data-bin="02">02
                  <div class="lid left"></div>
                  <div class="lid right"></div>
                  <div class="lid-duplicate left"></div>
                  <div class="lid-duplicate right"></div>
                </div>
                <div class="binProgress" data-bin="02">
                  <div class="binProgressTextContainer">
                    <span class="binProgressText back">0%</span>
                    <span class="binProgressText front">0%</span>
                  </div>
                  <div class="binProgressFill"></div>
                </div>

                <div class="binChart" data-bin="02">
                  <div class="chartHeader">02</div>
                  <div class="chartRow" data-temper="WO">
                    <div class="label" style="color:#8DD571; text-shadow:0 0 8px #fff;">WO</div>
                    <div class="bar" style="border: 3px solid #8DD571;" ><div class="fill" style="background:#8DD571; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="FC">
                    <div class="label" style="color:#F2D230; text-shadow:0 0 8px #fff;">FC</div>
                    <div class="bar" style="border: 3px solid #F2D230;" ><div class="fill" style="background:#F2D230; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="DR">
                    <div class="label" style="color:#F9A09F; text-shadow:0 0 8px #fff;">DR</div>
                    <div class="bar" style="border: 3px solid #F9A09F;" ><div class="fill" style="background:#F9A09F; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="MA">
                    <div class="label" style="color:#047FFD; text-shadow:0 0 8px #fff;">MA</div>
                    <div class="bar" style="border: 3px solid #047FFD;" ><div class="fill" style="background:#047FFD; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                </div>
              </div>
              
              <div class="binContainer">
                <div class="bin" data-bin="03">03
                  <div class="lid left"></div>
                  <div class="lid right"></div>
                  <div class="lid-duplicate left"></div>
                  <div class="lid-duplicate right"></div>
                </div>
                <div class="binProgress" data-bin="03">
                  <div class="binProgressTextContainer">
                    <span class="binProgressText back">0%</span>
                    <span class="binProgressText front">0%</span>
                  </div>
                  <div class="binProgressFill"></div>
                </div>
                <div class="binChart" data-bin="03">
                  <div class="chartHeader">03</div>
                  <div class="chartRow" data-temper="WO">
                    <div class="label" style="color:#8DD571; text-shadow:0 0 8px #fff;">WO</div>
                    <div class="bar" style="border: 3px solid #8DD571;" ><div class="fill" style="background:#8DD571; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="FC">
                    <div class="label" style="color:#F2D230; text-shadow:0 0 8px #fff;">FC</div>
                    <div class="bar" style="border: 3px solid #F2D230;" ><div class="fill" style="background:#F2D230; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="DR">
                    <div class="label" style="color:#F9A09F; text-shadow:0 0 8px #fff;">DR</div>
                    <div class="bar" style="border: 3px solid #F9A09F;" ><div class="fill" style="background:#F9A09F; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="MA">
                    <div class="label" style="color:#047FFD; text-shadow:0 0 8px #fff;">MA</div>
                    <div class="bar" style="border: 3px solid #047FFD;" ><div class="fill" style="background:#047FFD; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                </div>
              </div>
              
              <div class="binContainer">
                <div class="bin" data-bin="04">04
                  <div class="lid left"></div>
                  <div class="lid right"></div>
                  <div class="lid-duplicate left"></div>
                  <div class="lid-duplicate right"></div>
                </div>
                <div class="binProgress" data-bin="04">
                  <div class="binProgressTextContainer">
                    <span class="binProgressText back">0%</span>
                    <span class="binProgressText front">0%</span>
                  </div>
                  <div class="binProgressFill"></div>
                </div>

                <div class="binChart" data-bin="04">
                  <div class="chartHeader">04</div>
                  <div class="chartRow" data-temper="WO">
                    <div class="label" style="color:#8DD571; text-shadow:0 0 8px #fff;">WO</div>
                    <div class="bar" style="border: 3px solid #8DD571;" ><div class="fill" style="background:#8DD571; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="FC">
                    <div class="label" style="color:#F2D230; text-shadow:0 0 8px #fff;">FC</div>
                    <div class="bar" style="border: 3px solid #F2D230;" ><div class="fill" style="background:#F2D230; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="DR">
                    <div class="label" style="color:#F9A09F; text-shadow:0 0 8px #fff;">DR</div>
                    <div class="bar" style="border: 3px solid #F9A09F;" ><div class="fill" style="background:#F9A09F; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="MA">
                    <div class="label" style="color:#047FFD; text-shadow:0 0 8px #fff;">MA</div>
                    <div class="bar" style="border: 3px solid #047FFD;" ><div class="fill" style="background:#047FFD; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                </div>
              </div>
              
              <div class="binContainer">
                <div class="bin" data-bin="05">05
                  <div class="lid left"></div>
                  <div class="lid right"></div>
                  <div class="lid-duplicate left"></div>
                  <div class="lid-duplicate right"></div>
                </div>
                <div class="binProgress" data-bin="05">
                  <div class="binProgressTextContainer">
                    <span class="binProgressText back">0%</span>
                    <span class="binProgressText front">0%</span>
                  </div>
                  <div class="binProgressFill"></div>
                </div>

                <div class="binChart" data-bin="05">
                  <div class="chartHeader">05</div>
                  <div class="chartRow" data-temper="WO">
                    <div class="label" style="color:#8DD571; text-shadow:0 0 8px #fff;">WO</div>
                    <div class="bar" style="border: 3px solid #8DD571;" ><div class="fill" style="background:#8DD571; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="FC">
                    <div class="label" style="color:#F2D230; text-shadow:0 0 8px #fff;">FC</div>
                    <div class="bar" style="border: 3px solid #F2D230;" ><div class="fill" style="background:#F2D230; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="DR">
                    <div class="label" style="color:#F9A09F; text-shadow:0 0 8px #fff;">DR</div>
                    <div class="bar" style="border: 3px solid #F9A09F;"><div class="fill" style="background:#F9A09F; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                  <div class="chartRow" data-temper="MA">
                    <div class="label" style="color:#047FFD; text-shadow:0 0 8px #fff;">MA</div>
                    <div class="bar" style="border: 3px solid #047FFD;"><div class="fill" style="background:#047FFD; box-shadow:0 0 8px #fff;"></div></div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- SVG container for dynamic lid connectors (drawn only while lids are animating) -->
            <svg id="connectorContainer" xmlns="http://www.w3.org/2000/svg" style="position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; z-index: 7;"></svg>
            
            <!-- Popup Elements -->
            <div id="popup">NOPE</div>
            <div id="popupContaminated">PLEASE DO NOT BIN HEALTHY DATA</div>
            <div id="popupWrongBin">WRONG BIN</div>
            
            <!-- Footer Container -->
            <div id="footerContainer">
              <div id="footerSeparator" class="separator">
                <div class="line"></div>
              </div>
              <div id="footerText">0x00  :  0x00</div>
            </div>
          <div id="customCursor">
            <img src="cursor.png" alt="custom cursor">
          </div>

        </div> <!-- end of #mainContainer -->
      </div> <!-- end of appContainer -->
      
  </div>

  <script>
    (function(){
      "use strict";
  
      /* ==================================================
         1. Configuration & Global Variables
      ================================================== */
      const settings = {
        totalCycleDuration: 6000,       // ms
        sourcePauseDuration: 2000,      // ms (first phase of cycle)
        waveBurstDuration: 4000,        // ms (remaining cycle)
        depositDuration: 1000,
        clearDuration: 1000,
        punishDuration: 1000,
        baseCellSize: 40,
        zoomFactor: 1.0,
        collisionThreshold: 20,
        baseFont: 16                   // base font size (to be scaled by zoomFactor)
      };
  
      let pageLoadStart = performance.now();
      let gridOffset = { x: 0, y: 0 };
      let hexOffset = { x: 0, y : 0 }
      let keysPressed = {};
      let removedCells = new Set();
      let repopulatedCells = {};
      let capturedGroup = null;
      let selectedBin = null;
      let inputLocked = false;
      let binAnimationActive = false;
      let clearAnimating = false;
      let clearStartTime = 0;
      let punishCells = null;
      let depositAnimating = false;
      let depositStartTime = 0;
      let activeSourceGroup = null;
      let punishActive = false;
      let punishStartTime = 0;
      let totalProgressPoints = 0;
      let binsData = {
        "01": { WO: 0, FC: 0, DR: 0, MA: 0 },
        "02": { WO: 0, FC: 0, DR: 0, MA: 0 },
        "03": { WO: 0, FC: 0, DR: 0, MA: 0 },
        "04": { WO: 0, FC: 0, DR: 0, MA: 0 },
        "05": { WO: 0, FC: 0, DR: 0, MA: 0 }
      };
  
      /* ==================================================
         2. DOM Element Caching
      ================================================== */
      const canvas = document.getElementById("gridCanvas");
      canvas.style.pointerEvents = "auto"; // allow cell selection
      const ctx = canvas.getContext("2d");
      const totalProgressName = document.getElementById("totalProgressName");
      const totalProgressText = document.getElementById("totalProgressText");
      const progressBlocker = document.getElementById("progressBlocker");
      const binsEls = document.querySelectorAll(".bin");
      const canvasContainer = document.getElementById("canvasContainer");
  
      /* ==================================================
         3. Utility Functions
      ================================================== */

      function updateFooterWithHexOffsets() {
        const cellSize = 40;
        let offsetX = Math.floor(hexOffset.x / cellSize);
        let offsetY = Math.floor(hexOffset.y / cellSize);
        let hexX = "0x" + Math.abs(offsetX).toString(16).padStart(2, "0").toUpperCase();
        let hexY = "0x" + Math.abs(offsetY).toString(16).padStart(2, "0").toUpperCase();
        document.getElementById("footerText").textContent = `${hexX}  :  ${hexY}`;
      }

      // Update the footer every 100ms
      setInterval(updateFooterWithHexOffsets, 100);

      // 
      //
      //               CHECKPOINT - PROGRESS PERCENT
      //               (adjust difficultyFactor to smaller number for faster file completion) (2000 default)
      //

      // Update overall progress display.
      function updateOverallProgress() {
        let difficultyFactor = 500;
        const percentage = (totalProgressPoints / difficultyFactor) * 100;
        totalProgressText.textContent = Math.floor(percentage) + "% Complete";
        progressBlocker.style.transform = `translateX(${percentage}%)`;
      }
  
      // Resize the canvas to match its container.
      function resizeCanvas() {
        canvas.width = canvasContainer.clientWidth;
        canvas.height = canvasContainer.clientHeight;
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
  
      // Return pseudo-random cell data.
      function getCellData(i, j) {
        let seed = (i * 374761393) ^ (j * 668265263);
        seed = ((seed >>> 0) ^ (seed >>> 13)) >>> 0;
        const digit = seed % 10;
        const phase = (seed % 1000) / 1000 * Math.PI * 2;
        const initialFadeDelay = (seed % 2000) / 1000;
        return { digit, phase, initialFadeDelay };
      }
  
      // Returns true if cell (i,j) is adjacent to any already captured.
      function isAdjacentToCaptured(i, j) {
        if (!capturedGroup || capturedGroup.cells.length === 0) return true;
        return capturedGroup.cells.some(cell =>
          Math.abs(cell.i - i) <= 1 && Math.abs(cell.j - j) <= 1
        );
      }
  
      // Capture a cell if adjacent.
      function captureCell(i, j, worldX, worldY, data, cellKey, currentFontSize) {
        if (!capturedGroup) {
          capturedGroup = { cells: [], captureTime: Date.now(), screenPos: { x: 0, y: 0 } };
        }
        if (!isAdjacentToCaptured(i, j)) return;
        if (!capturedGroup.cells.find(c => c.i === i && c.j === j)) {
          capturedGroup.cells.push({
            i, j, origX: worldX, origY: worldY,
            digit: data.digit, phase: data.phase, capturedFont: currentFontSize
          });
          removedCells.add(cellKey);
        }
      }
  
      // Compute on-screen position for cell (i,j).
      function getCellScreenPos(i, j, data) {
        const cellSize = settings.baseCellSize * settings.zoomFactor;
        const worldX = i * cellSize + cellSize / 2;
        const worldY = j * cellSize + cellSize / 2;
        const t = performance.now() / 1000;
        const floatX = Math.sin(t + data.phase) * 4;
        const floatY = Math.cos(t + data.phase) * 4;
        return { x: worldX + floatX - gridOffset.x, y: worldY + floatY - gridOffset.y };
      }
  
      // Start deposit animation moving captured cells toward a bin.
      function startDepositAnimation(binId) {
        if (!capturedGroup || capturedGroup.cells.length === 0) return;
        inputLocked = true;
        binAnimationActive = true;
        const binEl = document.querySelector(`.bin[data-bin="${binId}"]`);
        const binRect = binEl.getBoundingClientRect();
        const canvasRect = canvas.getBoundingClientRect();
        const targetCanvas = {
          x: binRect.left + binRect.width / 2 - canvasRect.left,
          y: binRect.top + binRect.height / 2 - canvasRect.top
        };
        capturedGroup.cells.forEach(cell => {
          let key = cell.i + "," + cell.j;
          let data = repopulatedCells[key] || { digit: cell.digit, phase: cell.phase };
          cell.depositStart = getCellScreenPos(cell.i, cell.j, data);
          cell.depositTarget = { x: targetCanvas.x, y: targetCanvas.y };
          const dx = cell.depositTarget.x - cell.depositStart.x;
          const dy = cell.depositTarget.y - cell.depositStart.y;
          cell.depositDistance = Math.sqrt(dx * dx + dy * dy);
        });
        let sortedCells = capturedGroup.cells.slice().sort((a, b) => a.depositDistance - b.depositDistance);
        sortedCells.forEach((cell, index) => {
          cell.depositDelay = index * 10;
        });
        depositAnimating = true;
        depositStartTime = Date.now();
      }
  
      // Determine winning temper(s) based on captured cell digits.
      function determineWinningTemper(cells) {
        const freq = {};
        cells.forEach(cell => {
          const d = cell.digit;
          freq[d] = (freq[d] || 0) + 1;
        });
        const maxFreq = Math.max(...Object.values(freq));
        let winners = Object.keys(freq).filter(d => freq[d] === maxFreq).map(Number);
        const allowedWinners = winners.filter(d => d !== 1 && d !== 6);
        if (allowedWinners.length > 0) winners = allowedWinners;
        else {
          const nextFreq = Math.max(...Object.values(freq).filter(f => f < maxFreq));
          winners = Object.keys(freq).filter(d => d != 1 && d != 6 && freq[d] === nextFreq).map(Number);
        }
        const temperWinners = winners.map(d => {
          if (d === 0 || d === 9) return "WO";
          if (d === 2 || d === 8) return "FC";
          if (d === 3 || d === 7) return "DR";
          if (d === 4 || d === 5) return "MA";
        });
        return Array.from(new Set(temperWinners));
      }
  
      // Display a popup message.
      function showPopup(message, popupId = "popup") {
        const popup = document.getElementById(popupId);
        if (popup) {
          popup.textContent = message;
          popup.style.display = "block";
          setTimeout(() => { popup.style.display = "none"; }, 2000);
        }
      }
  
      // Animate the temper chart rising for the given bin.
      function animateTempersChart(binId, callback) {
        const chart = document.querySelector(`.binChart[data-bin="${binId}"]`);
        chart.style.height = "240px";
        // Force reflow.
        void chart.offsetHeight;
        setTimeout(() => {
          const temperWinners = determineWinningTemper(capturedGroup.cells);
          if (temperWinners.length === 0) {
            showPopup("NOPE");
          } else {
            temperWinners.forEach(temp => {
              binsData[binId][temp] = Math.min(100, binsData[binId][temp] + 1);
            });
          }
          chart.querySelectorAll(".chartRow").forEach(row => {
            const temper = row.getAttribute("data-temper");
            const value = binsData[binId][temper] || 0;
            row.querySelector(".fill").style.width = value + "%";
          });
        }, 750);
        setTimeout(() => {
          chart.style.height = "0";
          setTimeout(callback, 1000);
        }, 2250);
      }
  
      // Update the bin progress bar and text.
      function updateBinProgress(binId) {
        const sum = binsData[binId].WO + binsData[binId].FC + binsData[binId].DR + binsData[binId].MA;
        // CHECKPOINT Bin percentage, change 400 DEFAULT to lower number for faster bin progress for testing purposes
        const percentage = (sum / 100) * 100;
        const progressContainer = document.querySelector(`.binProgress[data-bin="${binId}"]`);
        const fillEl = progressContainer.querySelector(".binProgressFill");
        fillEl.style.width = percentage + "%";
        const backText = progressContainer.querySelector(".binProgressText.back");
        const frontText = progressContainer.querySelector(".binProgressText.front");
        const textContent = Math.floor(percentage) + "%";
        backText.textContent = textContent;
        frontText.textContent = textContent;
        frontText.style.clipPath = `inset(0 calc(100% - ${percentage}%) 0 0)`;
        frontText.style.webkitClipPath = `inset(0 calc(100% - ${percentage}%) 0 0)`;
      }
  
      // Initialize a new source group.
      function initSourceGroup() {
        const visIStart = Math.floor(gridOffset.x / settings.baseCellSize);
        const visIEnd = Math.floor((gridOffset.x + canvas.width) / settings.baseCellSize);
        const visJStart = Math.floor(gridOffset.y / settings.baseCellSize);
        const visJEnd = Math.floor((gridOffset.y + canvas.height) / settings.baseCellSize);
        const i0 = visIStart + Math.floor(Math.random() * (visIEnd - visIStart + 1));
        const j0 = visJStart + Math.floor(Math.random() * (visJEnd - visJStart + 1));
        const key = i0 + "," + j0;
        const sourceData = repopulatedCells[key] || getCellData(i0, j0);
        const frequency = Math.floor(Math.random() * 5) + 1;
        let candidates = [];
        for (let di = -5; di <= 5; di++) {
          for (let dj = -5; dj <= 5; dj++) {
            if (di === 0 && dj === 0) continue;
            const dist = Math.sqrt(di * di + dj * dj);
            candidates.push({ key: (i0 + di) + "," + (j0 + dj), dist });
          }
        }
        candidates.sort((a, b) => a.dist - b.dist);
        const partners = candidates.slice(0, Math.floor(Math.random() * 5) + 5).map(p => p.key);
        activeSourceGroup = {
          sourceKey: key,
          source_i: i0,
          source_j: j0,
          sourceData: getCellData(i0, j0),
          partners: partners,
          frequency: frequency,
          startTime: performance.now()
        };
        console.log("Active source group initialized:", activeSourceGroup);
      }
  
      function safeInitSourceGroup() {
        const elapsed = performance.now() - pageLoadStart;
        if (elapsed < 7000) {
          setTimeout(safeInitSourceGroup, 7000 - elapsed);
          return;
        }
        initSourceGroup();
      }
  
      // Punish the source group (with popup and cell reset).
      function punishSourceGroup() {
        showPopup("NOPE");
        punishActive = true;
        punishStartTime = performance.now();
        let unionCells = capturedGroup ? capturedGroup.cells.slice() : [];
        if (activeSourceGroup) {
          const sourceKey = activeSourceGroup.source_i + "," + activeSourceGroup.source_j;
          if (!unionCells.some(cell => cell.i + "," + cell.j === sourceKey)) {
            const data = repopulatedCells[sourceKey] || activeSourceGroup.sourceData;
            unionCells.push({ i: activeSourceGroup.source_i, j: activeSourceGroup.source_j, digit: data.digit, phase: data.phase, capturedFont: settings.baseFont * settings.zoomFactor });
          }
          activeSourceGroup.partners.forEach(partnerKey => {
            if (!unionCells.some(cell => cell.i + "," + cell.j === partnerKey)) {
              const parts = partnerKey.split(",").map(Number);
              const data = repopulatedCells[partnerKey] || getCellData(parts[0], parts[1]);
              unionCells.push({ i: parts[0], j: parts[1], digit: data.digit, phase: data.phase, capturedFont: settings.baseFont * settings.zoomFactor });
            }
          });
        }
        punishCells = unionCells;
        capturedGroup = null;
        setTimeout(() => {
          if (punishCells) {
            punishCells.forEach(cell => {
              removedCells.delete(cell.i + "," + cell.j);
              repopulatedCells[cell.i + "," + cell.j] = {
                digit: Math.floor(Math.random() * 10),
                phase: Math.random() * 2 * Math.PI,
                fadeStart: Date.now() + Math.random() * 1000
              };
            });
          }
          selectedBin = null;
          binsEls.forEach(bin => bin.classList.remove("open"));
          punishActive = false;
          punishCells = null;
          activeSourceGroup = null;
          setTimeout(initSourceGroup, Math.random() * 10000);
        }, settings.punishDuration + 1000);
      }
  
      function drawSourceGroupPunish() {
        if (!punishCells) return;
        const elapsed = performance.now() - punishStartTime;
        const scale = Math.max(0, 1 - (elapsed / settings.punishDuration));
        punishCells.forEach(cell => {
          const pos = getCellScreenPos(cell.i, cell.j, cell);
          ctx.shadowColor = "#FFFFFF";
          ctx.shadowBlur = 8;
          ctx.font = `bold ${cell.capturedFont * scale}px Gotham, sans-serif`;
          ctx.fillStyle = "#37DFEF";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(cell.digit, pos.x, pos.y);
          ctx.shadowBlur = 0;
        });
      }
  
      /* ------------------------------------------------
         Lids Connector Helpers (for bin lid polygons)
         ------------------------------------------------
         Note: We set the connector container’s z-index
         later (in updateBinParallelograms) so that it is
         behind the temper charts.
      ------------------------------------------------ */
      function getPivotScreenPosition(elem, side) {
        const parentRect = elem.offsetParent.getBoundingClientRect();
        const elemLeft = elem.offsetLeft;
        const elemTop = elem.offsetTop;
        return side === 'left'
          ? { x: parentRect.left + elemLeft, y: parentRect.top + elemTop }
          : { x: parentRect.left + elemLeft + elem.offsetWidth, y: parentRect.top + elemTop };
      }
      function getFreeEdgePoint(elem, side) {
        const computedStyle = window.getComputedStyle(elem);
        const transform = computedStyle.transform;
        let angle = 0;
        if (transform && transform !== "none") {
          const values = transform.split('(')[1].split(')')[0].split(',');
          angle = Math.atan2(parseFloat(values[1]), parseFloat(values[0]));
        }
        const localX = side === 'left' ? elem.offsetWidth : -elem.offsetWidth;
        const localY = elem.offsetHeight / 2;
        const rotatedX = localX * Math.cos(angle) - localY * Math.sin(angle);
        const rotatedY = localX * Math.sin(angle) + localY * Math.cos(angle);
        const pivot = getPivotScreenPosition(elem, side);
        let freeEdge = { x: pivot.x + rotatedX, y: pivot.y + rotatedY };
        freeEdge.y += 5;
        freeEdge.x += (side === 'left' ? 3 : 0.8);
        return freeEdge;
      }
      function updateBinParallelograms() {
        const connectorSVG = document.getElementById("connectorContainer");
        // Lower the connector container's z-index so it appears behind the temper charts.
        connectorSVG.style.zIndex = "3";
        connectorSVG.innerHTML = "";
        const containerRect = connectorSVG.getBoundingClientRect();
        const svgns = "http://www.w3.org/2000/svg";
  
        document.querySelectorAll(".bin").forEach(bin => {
          if (!bin.classList.contains("open") && !bin.classList.contains("closing")) return;
          // Left polygon
          const leftLid = bin.querySelector(".lid.left");
          const leftDup = bin.querySelector(".lid-duplicate.left");
          if (leftLid && leftDup) {
            let pivotLeft = getPivotScreenPosition(leftLid, 'left');
            let freeLeft = getFreeEdgePoint(leftLid, 'left');
            let freeLeftDup = getFreeEdgePoint(leftDup, 'left');
            let pivotLeftDup = getPivotScreenPosition(leftDup, 'left');
            [pivotLeft, freeLeft, freeLeftDup, pivotLeftDup].forEach(pt => {
              pt.x = pt.x + 2 - containerRect.left;
              pt.y = pt.y - containerRect.top;
            });
            const leftPoly = document.createElementNS(svgns, "polygon");
            leftPoly.setAttribute("points", `${pivotLeft.x},${pivotLeft.y} ${freeLeft.x},${freeLeft.y} ${freeLeftDup.x},${freeLeftDup.y} ${pivotLeftDup.x},${pivotLeftDup.y}`);
            leftPoly.setAttribute("stroke", "#37DFEF");
            leftPoly.setAttribute("stroke-width", "3");
            leftPoly.setAttribute("fill", "#001C2E");
            leftPoly.style.filter = "drop-shadow(0 0 4px #fff)";
            connectorSVG.appendChild(leftPoly);
          }
          // Right polygon
          const rightLid = bin.querySelector(".lid.right");
          const rightDup = bin.querySelector(".lid-duplicate.right");
          if (rightLid && rightDup) {
            let pivotRight = getPivotScreenPosition(rightLid, 'right');
            let freeRight = getFreeEdgePoint(rightLid, 'right');
            let freeRightDup = getFreeEdgePoint(rightDup, 'right');
            let pivotRightDup = getPivotScreenPosition(rightDup, 'right');
            [pivotRight, freeRight, freeRightDup, pivotRightDup].forEach(pt => {
              pt.x = pt.x + 5 - containerRect.left;
              pt.y = pt.y - containerRect.top;
            });
            const rightPoly = document.createElementNS(svgns, "polygon");
            rightPoly.setAttribute("points", `${pivotRight.x},${pivotRight.y} ${freeRight.x},${freeRight.y} ${freeRightDup.x},${freeRightDup.y} ${pivotRightDup.x},${pivotRightDup.y}`);
            rightPoly.setAttribute("stroke", "#37DFEF");
            rightPoly.setAttribute("stroke-width", "3");
            rightPoly.setAttribute("fill", "#001C2E");
            rightPoly.style.filter = "drop-shadow(0 0 4px #fff)";
            connectorSVG.appendChild(rightPoly);
          }
          // Third polygon connecting pivot points
          if (leftLid && rightLid && rightDup && leftDup) {
            let pivotLeft = getPivotScreenPosition(leftLid, 'left');
            let pivotRight = getPivotScreenPosition(rightLid, 'right');
            let pivotRightDup = getPivotScreenPosition(rightDup, 'right');
            let pivotLeftDup = getPivotScreenPosition(leftDup, 'left');
            pivotRight.x += 5;
            pivotRightDup.x += 5;
            pivotLeft.x += 2;
            pivotLeftDup.x += 2;
            [pivotLeft, pivotRight, pivotRightDup, pivotLeftDup].forEach(pt => {
              pt.x -= containerRect.left;
              pt.y -= containerRect.top;
            });
            const thirdPoly = document.createElementNS(svgns, "polygon");
            thirdPoly.setAttribute("points", `${pivotLeft.x},${pivotLeft.y} ${pivotRight.x},${pivotRight.y} ${pivotRightDup.x},${pivotRightDup.y} ${pivotLeftDup.x},${pivotLeftDup.y}`);
            thirdPoly.setAttribute("stroke", "#37DFEF");
            thirdPoly.setAttribute("stroke-width", "3");
            thirdPoly.setAttribute("fill", "#001C2E");
            thirdPoly.style.filter = "drop-shadow(0 0 4px #fff)";
            connectorSVG.appendChild(thirdPoly);
          }
        });
      }
  
      function countVisibleSourceGroupCells() {
        if (!activeSourceGroup) return 0;
        let count = 0;
        const cellSize = settings.baseCellSize * settings.zoomFactor;
        const minX = gridOffset.x - cellSize, maxX = gridOffset.x + canvas.width + cellSize;
        const minY = gridOffset.y - cellSize, maxY = gridOffset.y + canvas.height + cellSize;
        [activeSourceGroup.sourceKey, ...activeSourceGroup.partners].forEach(key => {
          const [i, j] = key.split(",").map(Number);
          const x = i * cellSize, y = j * cellSize;
          if (x >= minX && x <= maxX && y >= minY && y <= maxY) count++;
        });
        return count;
      }

      /* ==================================================
         4. Main Animation & Drawing Loop
      ================================================== */
      let currentMousePos = { x: 0, y: 0 };
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const now = performance.now();
        const cellSize = settings.baseCellSize * settings.zoomFactor;
  
        if (!depositAnimating && !capturedGroup) {
          const moveSpeed = 1.5; //adjust for different scroll speed
          if (keysPressed["ArrowUp"] || keysPressed["w"] || keysPressed["W"]) gridOffset.y -= moveSpeed;
          if (keysPressed["ArrowDown"] || keysPressed["s"] || keysPressed["S"]) gridOffset.y += moveSpeed;
          if (keysPressed["ArrowLeft"] || keysPressed["a"] || keysPressed["A"]) gridOffset.x -= moveSpeed;
          if (keysPressed["ArrowRight"] || keysPressed["d"] || keysPressed["D"]) gridOffset.x += moveSpeed;
        }

        if (!depositAnimating && !capturedGroup) {
          const moveSpeed = 1.5 ; //adjust for different scroll speed
          if (keysPressed["ArrowUp"] || keysPressed["w"] || keysPressed["W"]) hexOffset.y -= moveSpeed;
          if (keysPressed["ArrowDown"] || keysPressed["s"] || keysPressed["S"]) hexOffset.y += moveSpeed;
          if (keysPressed["ArrowLeft"] || keysPressed["a"] || keysPressed["A"]) hexOffset.x -= moveSpeed;
          if (keysPressed["ArrowRight"] || keysPressed["d"] || keysPressed["D"]) hexOffset.x += moveSpeed;
        }
  
        for (let i = Math.floor(gridOffset.x / cellSize) - 2; i <= Math.floor((gridOffset.x + canvas.width) / cellSize) + 2; i++) {
          for (let j = Math.floor(gridOffset.y / cellSize) - 2; j <= Math.floor((gridOffset.y + canvas.height) / cellSize) + 2; j++) {
            const key = i + "," + j;
            if (removedCells.has(key)) continue;
            // Determine if this cell belongs to the active source group.
            let isSourceGroupCell = false;
            if (activeSourceGroup &&
                (key === activeSourceGroup.source_i + "," + activeSourceGroup.source_j ||
                activeSourceGroup.partners.includes(key))) {
              isSourceGroupCell = true;
            }
            if (capturedGroup && capturedGroup.cells.some(c => c.i === i && c.j === j)) continue;
            const data = repopulatedCells[key] || getCellData(i, j);
            const pos = getCellScreenPos(i, j, data);
            let alpha = 1.0;
            if (repopulatedCells[key]) {
              const dt = Math.max(0, (Date.now() - repopulatedCells[key].fadeStart) / 1000);
              alpha = dt < 1 ? dt : 1;
            } else {
              const elapsed = (performance.now() - pageLoadStart) / 1000;
              alpha = elapsed < data.initialFadeDelay ? 0 : (elapsed >= 3 ? 1 : (elapsed - data.initialFadeDelay) / (3 - data.initialFadeDelay));
            }
            ctx.globalAlpha = alpha;
            ctx.shadowColor = "#FFFFFF";
            ctx.shadowBlur = 8;
            const d = Math.hypot(pos.x - currentMousePos.x, pos.y - currentMousePos.y);
            let fontSize = settings.baseFont * settings.zoomFactor + (24 * settings.zoomFactor * Math.max(0, 1 - d / (2 * cellSize)));
  
            // --- Source Group Animation Branch (Baseline Logic) ---
            if (activeSourceGroup && activeSourceGroup.startTime !== undefined) {
              const currentTimeEffective = performance.now() - activeSourceGroup.startTime;
              const amplitude = 0.5;
              const cycleTime = currentTimeEffective % settings.totalCycleDuration;
              if (isSourceGroupCell) {
                const transitionDuration = 200;
                if (cycleTime < settings.sourcePauseDuration) {
                  fontSize *= 1 + amplitude * (cycleTime / settings.sourcePauseDuration);
                } else if (cycleTime < settings.sourcePauseDuration + transitionDuration) {
                  const t = (cycleTime - settings.sourcePauseDuration) / transitionDuration;
                  const scaleFactor = (1 + amplitude) * (1 - t) + t;
                  fontSize *= scaleFactor;
                }
                // After the pause and transition, source group cells remain at normal size.
                } else {
                  if (cycleTime >= settings.sourcePauseDuration) {
                    let maxScale = 1;
                    const freq = activeSourceGroup.frequency;
                    const waveLife = settings.waveBurstDuration;
                    const threshold = 1.0;
                    // For non-source group cells, consider all cells in the source group.
                    const groupCells = [{ i: activeSourceGroup.source_i, j: activeSourceGroup.source_j }];
                    activeSourceGroup.partners.forEach(key => {
                      const parts = key.split(",").map(Number);
                      groupCells.push({ i: parts[0], j: parts[1] });
                    });
                    const waveRadius = 4
                    const dGroup = Math.min(...groupCells.map(cell => Math.sqrt((i - cell.i)**2 + (j - cell.j)**2)));
                    if (dGroup <= waveRadius) {     //
                      const currentCycle = Math.floor(currentTimeEffective / settings.totalCycleDuration);
                      let cycleIndices = [currentCycle];
                      if (currentCycle > 0) cycleIndices.push(currentCycle - 1);
                      for (const n of cycleIndices) {
                        for (let k = 0; k < freq; k++) {
                          let launchTime = n * settings.totalCycleDuration + settings.sourcePauseDuration + (k / freq) * settings.waveBurstDuration;
                          let age = currentTimeEffective - launchTime;
                          if (age < 0 || age > waveLife) continue;
                          let t_effect = age / waveLife;
                          let r_wave = t_effect * 23;
                          let diff = Math.abs(dGroup - r_wave);
                          if (diff < threshold) {
                            let effect = (1 - (diff / threshold)) * (1 - dGroup / 23);
                            let candidateScale = 1 + effect * amplitude;
                            if (candidateScale > maxScale) maxScale = candidateScale;
                          }
                        }
                      }
                    fontSize *= maxScale;
                  }
                }
              }
            }
            // Draw the cell digit.
            ctx.font = `bold ${fontSize}px Gotham, sans-serif`;
            ctx.fillStyle = "#37DFEF";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(data.digit, pos.x, pos.y);
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
            if (d < settings.collisionThreshold) {
              if (mouseDown && !inputLocked && isAdjacentToCaptured(i, j)) {
                captureCell(i, j, i * cellSize + cellSize/2, j * cellSize + cellSize/2, data, key, fontSize);
              }
            }
          }
        }
  
        // --- Draw Captured Cells ---
        if (capturedGroup && !binAnimationActive && !depositAnimating) {
          if (clearAnimating) {
            const elapsed = now - clearStartTime;
            const tClear = Math.min(1, elapsed / settings.clearDuration);
            capturedGroup.cells.forEach(cell => {
              const pos = getCellScreenPos(cell.i, cell.j, cell);
              const d = Math.hypot(pos.x - currentMousePos.x, pos.y - currentMousePos.y);
              const normalFont = settings.baseFont * settings.zoomFactor + (24 * settings.zoomFactor * Math.max(0, 1 - d/(2 * cellSize)));
              const interpFont = cell.capturedFont * (1 - tClear) + normalFont * tClear;
              ctx.shadowColor = "#FFFFFF";
              ctx.shadowBlur = 8;
              ctx.font = `bold ${interpFont}px Gotham, sans-serif`;
              ctx.fillStyle = "#37DFEF";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(cell.digit, pos.x, pos.y);
              ctx.shadowBlur = 0;
            });
            if (elapsed >= settings.clearDuration) {
              capturedGroup.cells.forEach(cell => removedCells.delete(cell.i + "," + cell.j));
              capturedGroup = null;
              clearAnimating = false;
              binsEls.forEach(bin => bin.classList.remove("open"));
            }
          } else {
            capturedGroup.cells.forEach(cell => {
              const key = cell.i + "," + cell.j;
              const pos = getCellScreenPos(cell.i, cell.j, cell);
              ctx.shadowColor = "#FFFFFF";
              ctx.shadowBlur = 8;
              ctx.font = `bold ${cell.capturedFont}px Gotham, sans-serif`;
              ctx.fillStyle = "#37DFEF";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(cell.digit, pos.x, pos.y);
              ctx.shadowBlur = 0;
            });
          }
        }
  
        // --- Deposit Animation ---
        if (capturedGroup && depositAnimating) {
          let allFinished = true;
          capturedGroup.cells.forEach(cell => {
            const effectiveElapsed = Date.now() - (depositStartTime + cell.depositDelay);
            const tNorm = Math.min(1, Math.max(0, effectiveElapsed / settings.depositDuration));
            if (tNorm < 1) allFinished = false;
            const start = cell.depositStart;
            const target = cell.depositTarget;
            const currentPos = {
              x: start.x + (target.x - start.x) * tNorm,
              y: start.y + (target.y - start.y) * tNorm
            };
            ctx.shadowColor = "#FFFFFF";
            ctx.shadowBlur = 8;
            ctx.font = `bold ${cell.capturedFont}px Gotham, sans-serif`;
            ctx.fillStyle = "#37DFEF";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(cell.digit, currentPos.x, currentPos.y);
            ctx.shadowBlur = 0;
          });
          if (allFinished) {
            depositAnimating = false;
            const temperWinners = determineWinningTemper(capturedGroup.cells);
            if (temperWinners.length === 0) showPopup("NOPE");
            else temperWinners.forEach(temp => {
              binsData[selectedBin][temp] = Math.min(100, binsData[selectedBin][temp] + 1);
            });
            const capturedCells = capturedGroup.cells.slice();
            animateTempersChart(selectedBin, () => {
              const binEl = document.querySelector(`.bin[data-bin="${selectedBin}"]`);
              binEl.classList.remove("open");
              setTimeout(() => {
                capturedCells.forEach(cell => {
                  removedCells.delete(cell.i + "," + cell.j);
                  repopulatedCells[cell.i + "," + cell.j] = {
                    digit: Math.floor(Math.random() * 10),
                    phase: Math.random() * 2 * Math.PI,
                    fadeStart: Date.now() + Math.random() * 1000
                  };
                });
              }, 1000);
              updateBinProgress(selectedBin);
              totalProgressPoints = Object.values(binsData).reduce((sum, bin) =>
                sum + bin.WO + bin.FC + bin.DR + bin.MA, 0);
              updateOverallProgress();
              capturedGroup = null;
              selectedBin = null;
              binsEls.forEach(bin => bin.classList.remove("open"));
              binAnimationActive = false;
              inputLocked = false;
              setTimeout(initSourceGroup, Math.random() * 10000);
            });
          }
        }
  
        if (punishActive) {
          drawSourceGroupPunish();
        }
  
        updateBinParallelograms();
        requestAnimationFrame(draw);
      }
  
      /* ==================================================
         5. Event Listeners
      ================================================== */
      let mouseDown = false;
      canvas.addEventListener("mousedown", () => { if (!inputLocked) mouseDown = true; });
      canvas.addEventListener("mouseup", () => { mouseDown = false; });
      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        currentMousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
      });
  
      canvasContainer.addEventListener("wheel", function(e) {
        if (capturedGroup) return;
        e.preventDefault();
        const delta = -e.deltaY;
        const sensitivity = 0.001;
        let newZoom = settings.zoomFactor + delta * sensitivity;
        newZoom = Math.max(0.75, Math.min(3.0, newZoom));
        const rect = canvasContainer.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        gridOffset.x = (mx + gridOffset.x) * (newZoom / settings.zoomFactor) - mx;
        gridOffset.y = (my + gridOffset.y) * (newZoom / settings.zoomFactor) - my;
        settings.zoomFactor = newZoom;
      }, { passive: false });
  
      window.addEventListener("keydown", (e) => {
        keysPressed[e.key] = true;
        if (e.key === "Backspace" && capturedGroup && !inputLocked && !depositAnimating && !clearAnimating) {
          e.preventDefault();
          clearAnimating = true;
          clearStartTime = performance.now();
          binsEls.forEach(bin => bin.classList.remove("open"));
        }
        if (e.key !== "Enter" && capturedGroup) {
          let key = e.key.length === 1 ? e.key.padStart(2, "0") : e.key;
          if (["01", "02", "03", "04", "05"].includes(key)) {
            selectedBin = key;
            binsEls.forEach(bin => {
              bin.classList.toggle("open", bin.getAttribute("data-bin") === key);
            });
          }
        } else if (e.key === "Enter" && !depositAnimating) {
          if (!capturedGroup || capturedGroup.cells.length === 0 || !activeSourceGroup) {
            showPopup("NOPE");
            binsEls.forEach(bin => bin.classList.remove("open"));
            clearAnimating = true;
            clearStartTime = performance.now();
            return;
          }
          const activeKeys = [activeSourceGroup.source_i + "," + activeSourceGroup.source_j].concat(activeSourceGroup.partners);
          if (!capturedGroup.cells.some(cell => activeKeys.includes(cell.i + "," + cell.j))) {
            showPopup("NOPE");
            binsEls.forEach(bin => bin.classList.remove("open"));
            clearAnimating = true;
            clearStartTime = performance.now();
            return;
          }
          const nonSourceCount = capturedGroup.cells.filter(cell => !activeKeys.includes(cell.i + "," + cell.j)).length;
          if (nonSourceCount > 2) {
            showPopup("PLEASE DO NOT BIN HEALTHY DATA", "popupContaminated");
            punishSourceGroup();
            return;
          }
          if (!selectedBin) {
            punishSourceGroup();
            return;
          }
          if (parseInt(selectedBin, 10) !== activeSourceGroup.frequency) {
            showPopup("WRONG BIN", "popupWrongBin");
            punishSourceGroup();
            return;
          } else {
            startDepositAnimation(selectedBin);
            activeSourceGroup = null;
          }
        }
      });
      window.addEventListener("keyup", (e) => { keysPressed[e.key] = false; });
  
      /* ==================================================
         6. Initialization & Periodic Checks
      ================================================== */
      draw();
      setTimeout(safeInitSourceGroup, 2000);
      setInterval(() => {
        if (activeSourceGroup) {
          const visibleCount = countVisibleSourceGroupCells();
          if (visibleCount === 0) {
            activeSourceGroup.notVisibleStart = activeSourceGroup.notVisibleStart || Date.now();
            if (Date.now() - activeSourceGroup.notVisibleStart > 5000) {
              console.log("Source group not visible for >5 seconds, resetting.");
              activeSourceGroup = null;
              initSourceGroup();
            }
          } else {
            activeSourceGroup.notVisibleStart = null;
          }
        }
      }, 1000);
  
      /* ==================================================
         7. Additional Features
      ================================================== */
  
      // Process the Lumon logo image and append it to the globe container.
      window.addEventListener("load", function() {
        const img = new Image();
        img.src = "lumon_industries_logo.png";
        img.crossOrigin = "anonymous";
        img.onload = function() {
          const offCanvas = document.createElement("canvas");
          offCanvas.width = img.width;
          offCanvas.height = img.height;
          const offCtx = offCanvas.getContext("2d");
          offCtx.drawImage(img, 0, 0);
          const imageData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height);
          const data = imageData.data;
          for (let i = 0; i < data.length; i += 4) {
            if (data[i] > 240 && data[i+1] > 240 && data[i+2] > 240) {
              data[i] = 193;
              data[i+1] = 243;
              data[i+2] = 247;
              data[i+3] = 255;
            } else {
              data[i+3] = 0;
            }
          }
          offCtx.putImageData(imageData, 0, 0);
          const processedImg = new Image();
          processedImg.src = offCanvas.toDataURL();
          processedImg.style.position = "absolute";
          processedImg.style.zIndex = "0";
          processedImg.style.left = "50%";
          processedImg.style.top = "50%";
          processedImg.style.transform = "translate(-50%, -50%)";
          processedImg.style.width = "57%";
          processedImg.style.filter = "drop-shadow(0 0 7px #37dfef)";
          processedImg.style.opacity = 0;
          processedImg.style.animation = 'fadeIn 3s ease-out forwards';
          processedImg.id = "processedImg";
          const globeContainer = document.getElementById("globeContainer");
          globeContainer.appendChild(processedImg);
        };
        img.onerror = function(e) {
          console.error("Error loading image:", e);
        };
      });
  
      // Custom Cursor: ensure it follows the mouse.
      window.addEventListener("DOMContentLoaded", function() {
        const cursor = document.getElementById("customCursor");
        if (cursor) {
          cursor.style.pointerEvents = "none";
          cursor.style.position = "fixed";
        }
      });
      document.addEventListener('mousemove', function(e) {
        const cursor = document.getElementById('customCursor');
        if (cursor) {
          cursor.style.left = e.clientX + 'px';
          cursor.style.top = e.clientY + 'px';
        }
      });
      window.addEventListener('mousemove', function(e) {
        const cursor = document.getElementById('customCursor');
        if (cursor) {
          cursor.style.left = e.clientX + 'px';
          cursor.style.top = e.clientY + 'px';
        }
      });

      /* ==================================================
         8. Progress Saving
      ================================================== */

          // Update totalProgressName from the "filename" query parameter.
          const params = new URLSearchParams(window.location.search);
          const filename = params.get("filename")|| 'Pathfinder';
          window.addEventListener("DOMContentLoaded", function() {
            if (filename) totalProgressName.textContent = filename;
          });
          
          // Function to load progress data from localStorage
          function loadProgress() {
            const key = 'progress_' + filename;
            const savedState = localStorage.getItem(key);
            if (savedState) {
              try {
                const state = JSON.parse(savedState);
                if (typeof state.totalProgressPoints !== 'undefined') {
                  totalProgressPoints = state.totalProgressPoints;
                }
                if (state.binsData) {
                  binsData = state.binsData;
                }
                if (state.hexOffset) {
                  const xVal = Number(state.hexOffset.x);
                  const yVal = Number(state.hexOffset.y);
                  hexOffset.x = isNaN(xVal) ? 0 : xVal;
                  hexOffset.y = isNaN(yVal) ? 0 : yVal;
                }
                console.log(filename, "progress loaded:", state);
              } catch (error) {
                console.error("Error parsing saved progress for", filename, ":", error);
              }
            } else {
              console.log("No saved progress for", filename);
            }
          }
        
          // Function to save progress data to localStorage
          function saveProgress() {
            const key = 'progress_' + filename;
            const state = {
              totalProgressPoints: totalProgressPoints,
              binsData: binsData,
              hexOffset: { x: hexOffset.x, y: hexOffset.y }
            };
            try {
              localStorage.setItem(key, JSON.stringify(state));
              console.log("Progress saved for", filename, ":", state);
            } catch (error) {
              console.error("Error saving progress for", filename, ":", error);
            }
          }
        
          // Load progress when the page loads
          window.addEventListener('load', loadProgress);
          // Save progress just before the page is unloaded
          window.addEventListener('beforeunload', saveProgress);
          window.addEventListener('pagehide', saveProgress);
          
          // This ensures the progress bars are correct on page load.
          window.addEventListener('load', function() {
            // Call updateOverallProgress to update the overall progress display.
            updateOverallProgress();
            // Call updateBinProgress for each bin
            for (const binId in binsData) {
              updateBinProgress(binId);
            }
          });

    })();

  </script> 

    <script> 
      // Inactivity timer variables
      const overlay = document.getElementById('bouncingGlobeOverlay');
      const inactivityDuration = 30000; // 30 seconds
      let inactivityTimer;

      // Reset (or start) the inactivity timer; also ensure overlay is hidden on input.
      function resetInactivityTimer() {
        // Immediately hide the overlay if it’s visible.
        overlay.style.opacity = 0;
        clearTimeout(inactivityTimer);
        inactivityTimer = setTimeout(() => {
          overlay.style.opacity = 1;  // fade in after 30 seconds of no input
          globe.style.opacity = 1;
        }, inactivityDuration);
      }

      // Listen for any user input (mousemove, keydown, mousedown, touchstart)
      ['mousemove', 'keydown', 'mousedown', 'touchstart'].forEach(evt => {
        document.addEventListener(evt, resetInactivityTimer, {passive: true});
      });
      resetInactivityTimer();  // start the timer on page load

      // Bounce animation for the globe SVG (DVD logo style)
      const globe = document.getElementById('globeSvg');
      let posX = 0, posY = 0;
      let velocityX = 2, velocityY = 2;

      function animateGlobe() {
        const overlayRect = overlay.getBoundingClientRect();
        const globeRect = globe.getBoundingClientRect();

        // update position
        posX += velocityX;
        posY += velocityY;

        // Bounce off the horizontal boundaries
        if (posX + globeRect.width > overlayRect.width || posX < 0) {
          velocityX = -velocityX;
          posX = Math.max(0, Math.min(posX, overlayRect.width - globeRect.width));
        }
        // Bounce off the vertical boundaries
        if (posY + globeRect.height > overlayRect.height || posY < 0) {
          velocityY = -velocityY;
          posY = Math.max(0, Math.min(posY, overlayRect.height - globeRect.height));
        }

        globe.style.transform = `translate(${posX}px, ${posY}px)`;
        requestAnimationFrame(animateGlobe);
      }
      animateGlobe();

    </script>

    <script>
      
      </script>
  

</body>
</html>
