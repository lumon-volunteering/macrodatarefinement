<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Macrodata Rolodex</title>
  <link rel="stylesheet" href="rolodex.css">
  
  <script>
    // When the static top tile is clicked, fade out the UI and then switch to mdrFinal.
    function loadMDR() {
      document.getElementById("uiContainer").style.opacity = 0;
      // After fade-out (0.7 seconds), navigate to mdrFinal with filename parameter.
      setTimeout(function() {
        var filename = document.getElementById('staticTopName').textContent;
        var mdrURL = "Refinement%20Terminal.html?filename=" + encodeURIComponent(filename);
        window.location.href = mdrURL;
      }, 700);
    }
  </script>
</head>
<body>
  <div id="pageWrapper">
    <img id="sticky1" src="sticky1.png" alt="sticky1">
    <img id="sticky2" src="sticky2.png" alt="sticky2">
    <img id="sticky3" src="sticky3.png" alt="sticky3">
    <img id="sticky4" src="sticky4.png" alt="sticky4">
    <img id="screenOverlay" src="overlay.png" alt="screenOverlay">
      <div id="appContainer" class="crt">

        <div id="bouncingGlobeOverlay"></div>

        <!-- Hidden white glow filter -->
        <svg width="0" height="0" xmlns="http://www.w3.org/2000/svg" style="position: absolute;">
          <filter id="whiteGlow">
            <feColorMatrix in="SourceGraphic" type="matrix"
              values="
                1 0 0 0 -0.2157
                0 1 0 0 -0.8745
                0 0 1 0 -0.9373
                0 0 0 1 0" result="subtracted"/>
            <feComponentTransfer in="subtracted" result="mask">
              <feFuncR type="linear" slope="100" intercept="-99.5"/>
              <feFuncG type="linear" slope="100" intercept="-99.5"/>
              <feFuncB type="linear" slope="100" intercept="-99.5"/>
              <feFuncA type="table" tableValues="0 1"/>
            </feComponentTransfer>
            <feGaussianBlur in="mask" stdDeviation="5" result="blur"/>
            <feFlood flood-color="white" result="glowColor"/>
            <feComposite in="glowColor" in2="blur" operator="in" result="glow"/>
            <feMerge>
              <feMergeNode in="glow"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </svg>
        
        <!-- UI elements wrapped in uiContainer for fade-out -->
        <div id="uiContainer">
          <div class="rolodex-container">
            <!-- New Vertical Pill Elements -->
            <div class="pill left-pill"></div>
            <div class="pill right-pill"></div>
            
            <!-- Static Top Tile (with filename and top tab) -->
            <div id="staticTop" class="static" onclick="loadMDR()">
              <div class="top-tab-container">
                <svg id="topTabSVG" width="50" height="25" viewBox="0 0 50 25">
                  <polygon points="10,0 40,0 50,25 0,25" fill="#c1f3f7" stroke="#37DFEF" stroke-width="3"/>
                  <text id="topTabText" x="25" y="12.5" text-anchor="middle" dominant-baseline="middle" fill="#001C2E" font-size="16" font-weight="bold">?</text>
                </svg>
              </div>
              <div class="static-file-name" id="staticTopName"></div>
              <div id="totalProgressPercent">0%</div>
              <div id="progressBarContainer" style="width: 100%; background: #001c2e; border-radius: 5px; overflow: hidden;">
                <div id="progressBar" style="width: 0%; height: 100%; background: #37DFEF; opacity: 0.3;"></div>
              </div>
              
            </div>
            <!-- Static Bottom Tile (only tab; no filename) -->
            <div id="staticBottom" class="static">
              <div class="bottom-tab-container">
                <svg id="bottomTabSVG" width="50" height="25" viewBox="0 0 50 25">
                  <polygon points="0,0 50,0 40,25 10,25" fill="#001C2E" stroke="#37DFEF" stroke-width="3"/>
                  <line x1="0" y1="0" x2="50" y2="0" stroke="#37DFEF" stroke-width="5"/>
                  <line x1="0" y1="0" x2="10" y2="25" stroke="#37DFEF" stroke-width="3"/>
                  <line x1="50" y1="0" x2="40" y2="25" stroke="#37DFEF" stroke-width="3"/>
                  <line x1="10" y1="25" x2="40" y2="25" stroke="#37DFEF" stroke-width="5"/>
                  <text id="bottomTabText" x="25" y="12.5" text-anchor="middle" dominant-baseline="middle" fill="#001C2E" font-size="16" font-weight="bold">?</text>
                </svg>
              </div>
            </div>
            <!-- Left and Right Line Stacks -->
            <div class="line-stack left-stack">
              <div class="line-stack-inner">
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
              </div>
            </div>
            <div class="line-stack right-stack">
              <div class="line-stack-inner">
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
                <div class="line"></div>
              </div>
            </div>
          </div>
        </div>

        <div id="customCursor">
          <img src="cursor.png" alt="custom cursor">
          </div>


    </div>
  </div>


  
  <script>
    // Animation settings
    const animationDuration = "0.5s";
    const animationEasing = "cubic-bezier(0.25, 0.46, 0.45, 0.94)";
    const animationTimeMs = parseFloat(animationDuration) * 1000; // 500ms

    // File list
    const files = [
      "Allentown",
      "Astoria",
      "Bellingham",
      "Billings",
      "Boda",
      "Cairnes",
      "Chicxulub",
      "Cielo",
      "Cold Harbor",
      "Coleman",
      "Cork",
      "Culpepper",
      "Dranesville",
      "Eau Claire",
      "Eminence",
      "Erie",
      "Fort Dodge",
      "Gold Coast",
      "Grimaldi",
      "Grimsby",
      "Hefei",
      "Homestead",
      "Horseshoe Bend",
      "Jaspur",
      "Jesup",
      "Kingsport",
      "Labrador",
      "Le Mars",
      "Lexington",
      "Longbranch",
      "Loveland",
      "Lucknow",
      "Merida",
      "Minsk",
      "Molde",
      "Montauk",
      "Moonbeam",
      "Morioka",
      "Nanning",
      "Narva",
      "Ocula",
      "Pacoima",
      "Rhodes",
      "Santa Mira",
      "Siena",
      "Sopchoppy",
      "St. Pierre",
      "Sunset Park",
      "Tan An",
      "Todos Santos",
      "Trinity",
      "Tumwater",
      "Vilnius",
      "Waynesboro",
      "Wellington",
      "Yakima",
      "Zurich"
    ];
    const total = files.length;
    let currentIndex = 0;

    // Mapping from starting letter to horizontal tab position.
    const tabPositions = {
      "A": "0px",
      "B": "9.04px",
      "C": "18.09px",
      "D": "27.14px",
      "E": "36.19px",
      "F": "45.238px",
      "G": "54.29px",
      "H": "63.33px",
      "J": "72.38px",
      "K": "81.43px",
      "L": "90.48px",
      "M": "99.52px",
      "N": "108.57px",
      "O": "117.61px",
      "P": "126.66px",
      "R": "135.72px",
      "S": "144.76px",
      "T": "153.81px",
      "V": "162.86px",
      "W": "171.90px",
      "Y": "180.95px",
      "Z": "190px"
    };

    // Precompute distinct starting letters from the file list.
    const distinctLetters = Array.from(new Set(files.map(f => f.trim()[0].toUpperCase())));

    // Global variable to track last bottom tab letter for translation logic.
    let lastBottomLetter = files[currentIndex].trim()[0].toUpperCase();

    // Grab static elements
    const staticTop = document.getElementById("staticTop");
    const staticBottom = document.getElementById("staticBottom");
    const topTabContainer = document.querySelector(".top-tab-container");
    const bottomTabContainer = document.querySelector(".bottom-tab-container");
    const staticTopName = document.getElementById("staticTopName");

    // Update bottom tab:
    function updateBottomTab(index) {
      let letter = files[index].trim()[0].toUpperCase();
      let topEdgeColor = (letter !== lastBottomLetter) ? "#001C2E" : "#37DFEF";
      bottomTabContainer.innerHTML = `
        <svg id="bottomTabSVG" width="50" height="25" viewBox="0 0 50 25">
          <polygon points="0,0 50,0 40,25 10,25" fill="#001C2E" stroke="#37DFEF" stroke-width="3"/>
          <line x1="0" y1="0" x2="50" y2="0" stroke="${topEdgeColor}" stroke-width="5"/>
          <line x1="0" y1="0" x2="10" y2="25" stroke="#37DFEF" stroke-width="3"/>
          <line x1="50" y1="0" x2="40" y2="25" stroke="#37DFEF" stroke-width="3"/>
          <line x1="10" y1="25" x2="40" y2="25" stroke="#37DFEF" stroke-width="5"/>
          <text id="bottomTabText" x="25" y="12.5" text-anchor="middle" dominant-baseline="middle" fill="#001C2E" font-size="16" font-weight="bold">${letter}</text>
        </svg>
      `;
      lastBottomLetter = letter;
      bottomTabContainer.style.left = tabPositions[letter] || "0px";
    }

    // Update top static tile:
    function updateTopStaticAndTab(index) {
      staticTopName.textContent = files[index];
      let currentLetter = files[index].trim()[0].toUpperCase();
      let letterIndex = distinctLetters.indexOf(currentLetter);
      let nextLetter = distinctLetters[(letterIndex + 1) % distinctLetters.length];
      document.getElementById("topTabText").textContent = nextLetter;
      topTabContainer.style.left = tabPositions[nextLetter] || "0px";
    }

    function updateStaticLayers() {
      updateTopStaticAndTab(currentIndex);
      updateBottomTab(currentIndex);
    }

    staticTopName.textContent = files[currentIndex];
    updateStaticLayers();

    let animationZIndex = 1000;
    let scrollLocked = false;
    let autoFlicking = true;
    let globalIndexOffset = 0;
    function updateRollers(delta) {
      globalIndexOffset += delta;
      while (globalIndexOffset >= 1) {
        document.querySelectorAll('.line-stack-inner').forEach(stack => {
          stack.appendChild(stack.firstElementChild);
        });
        globalIndexOffset -= 1;
      }
      while (globalIndexOffset < 0) {
        document.querySelectorAll('.line-stack-inner').forEach(stack => {
          stack.insertBefore(stack.lastElementChild, stack.firstElementChild);
        });
        globalIndexOffset += 1;
      }
      updateLinePositions();
    }

    let autoRollerInterval;
    function flashLine() {
      const line = document.createElement("div");
      line.classList.add("flash-line");
      document.querySelector(".rolodex-container").appendChild(line);
      setTimeout(() => { line.remove(); }, 16);
    }

    function createForwardAnimation(oldFile, newFile) {
      const container = document.createElement("div");
      container.classList.add("animation-overlay");
      container.style.zIndex = animationZIndex;
      animationZIndex--;
      
      const flipTop = document.createElement("div");
      flipTop.classList.add("animated");
      flipTop.style.bottom = "calc(50% + 10px)";
      flipTop.style.transformOrigin = "bottom center";
      flipTop.textContent = oldFile;
      flipTop.style.color = "#37DFEF";
      flipTop.style.animation = `flipOutTop ${animationDuration} ${animationEasing} forwards`;
      
      setTimeout(() => { flashLine(); }, animationTimeMs / 2);
      
      const flipBottom = document.createElement("div");
      flipBottom.classList.add("animated");
      flipBottom.style.top = "calc(50% + 10px)";
      flipBottom.style.transformOrigin = "top center";
      flipBottom.textContent = newFile;
      flipBottom.style.color = "transparent";
      flipBottom.style.animation = `flipInBottom ${animationDuration} ${animationEasing} forwards`;
      
      container.appendChild(flipTop);
      container.appendChild(flipBottom);
      document.querySelector(".rolodex-container").appendChild(container);
      
      flipBottom.addEventListener("animationend", () => {
        updateBottomTab(currentIndex);
        container.remove();
      }, { once: true });
    }

    function createBackwardAnimation(newFile, newIndex) {
      const container = document.createElement("div");
      container.classList.add("animation-overlay");
      container.style.zIndex = animationZIndex;
      animationZIndex--;
      
      const flipBottom = document.createElement("div");
      flipBottom.classList.add("animated");
      flipBottom.style.top = "calc(50% + 10px)";
      flipBottom.style.transformOrigin = "top center";
      flipBottom.textContent = newFile;
      flipBottom.style.color = "transparent";
      flipBottom.style.animation = `flipOutBottom ${animationDuration} ${animationEasing} forwards`;
      setTimeout(() => { flashLine(); }, animationTimeMs / 2);
      
      const flipTop = document.createElement("div");
      flipTop.classList.add("animated");
      flipTop.style.bottom = "calc(50% + 10px)";
      flipTop.style.transformOrigin = "bottom center";
      flipTop.textContent = newFile;
      flipTop.style.color = "#37DFEF";
      flipTop.style.animation = `flipInTop ${animationDuration} ${animationEasing} forwards`;
      
      container.appendChild(flipBottom);
      container.appendChild(flipTop);
      document.querySelector(".rolodex-container").appendChild(container);
      
      flipTop.addEventListener("animationend", () => {
        updateTopStaticAndTab(newIndex);
        currentIndex = newIndex;
        container.remove();
      }, { once: true });
    }

    window.addEventListener("load", () => {
      currentIndex = Math.floor(Math.random() * total);
      updateStaticLayers();
      
      autoRollerInterval = setInterval(() => {
        if (autoFlicking) {
          updateRollers(-0.1);
        }
      }, 50);
      
      const targetIndex = files.indexOf("Allentown");
      let flicksNeeded;
      if (currentIndex <= targetIndex) {
        flicksNeeded = targetIndex - currentIndex;
      } else {
        flicksNeeded = total - currentIndex + targetIndex;
      }
      if (flicksNeeded === 0) {
        autoFlicking = false;
        clearInterval(autoRollerInterval);
        return;
      }
      let delays = [];
      for (let i = 0; i < flicksNeeded; i++) {
        let p = (flicksNeeded === 1) ? 0 : i / (flicksNeeded - 1);
        let delayFactor = 1 - Math.pow(1 - p, 2);
        delays.push(delayFactor);
      }
      let sumFactors = delays.reduce((a, b) => a + b, 0);
      delays = delays.map(d => (d / sumFactors) * 3000);
      
      let cumulative = 0;
      for (let i = 0; i < flicksNeeded; i++) {
        cumulative += delays[i];
        setTimeout(() => {
          const oldFile = files[currentIndex];
          const newIndex = (currentIndex + 1) % total;
          const newFile = files[newIndex];
          currentIndex = newIndex;
          updateTopStaticAndTab(currentIndex);
          createForwardAnimation(oldFile, newFile);
          if (files[currentIndex] === "Allentown") {
            autoFlicking = false;
            clearInterval(autoRollerInterval);
          }
        }, cumulative);
      }
      setTimeout(() => { autoFlicking = false; clearInterval(autoRollerInterval); }, 3000);
    });

    document.addEventListener("wheel", (e) => {
      e.preventDefault();
      if (autoFlicking) return;
      if (scrollLocked) return;
      scrollLocked = true;
      setTimeout(() => { scrollLocked = false; }, 400);
      if (e.deltaY > 0) {
        const oldFile = files[currentIndex];
        const newIndex = (currentIndex + 1) % total;
        const newFile = files[newIndex];
        currentIndex = newIndex;
        updateTopStaticAndTab(currentIndex);
        createForwardAnimation(oldFile, newFile);
      } else {
        const newIndex = (currentIndex - 1 + total) % total;
        const newFile = files[newIndex];
        updateBottomTab(newIndex);
        createBackwardAnimation(newFile, newIndex);
      }
    }, { passive: false });

    const totalLines = 11;
    const containerHeight = 130;
    const lineHeight = 5;
    function linePosition(effectiveIndex) {
      let normalized = effectiveIndex / (totalLines - 1);
      return Math.pow((1 - Math.cos(Math.PI * normalized)) / 2, 1.5) * (containerHeight - lineHeight);
    }
    function updateLinePositions() {
      document.querySelectorAll('.line-stack-inner').forEach(stack => {
        Array.from(stack.children).forEach((line, i) => {
          let effectiveIndex = i - globalIndexOffset;
          line.style.top = linePosition(effectiveIndex) + 'px';
        });
      });
    }
    updateLinePositions();
    document.addEventListener('wheel', (e) => {
      const step = e.deltaY > 0 ? -0.1 : 0.1;
      globalIndexOffset += step;
      while (globalIndexOffset >= 1) {
        document.querySelectorAll('.line-stack-inner').forEach(stack => {
          stack.appendChild(stack.firstElementChild);
        });
        globalIndexOffset -= 1;
      }
      while (globalIndexOffset < 0) {
        document.querySelectorAll('.line-stack-inner').forEach(stack => {
          stack.insertBefore(stack.lastElementChild, stack.firstElementChild);
        });
        globalIndexOffset += 1;
      }
      updateLinePositions();
    });
  </script>
  

    <script>
      document.addEventListener('mousemove', function(e) {
        var cursor = document.getElementById('customCursor');
        cursor.style.left = e.clientX + 'px';
        cursor.style.top = e.clientY + 'px';
      });
    </script>


    <script>
      // Inactivity timer variables
      const overlay = document.getElementById('bouncingGlobeOverlay');
      const inactivityDuration = 30000; //30 seconds
      let inactivityTimer;

      // Reset (or start) the inactivity timer; also ensure overlay is hidden on input.
      function resetInactivityTimer() {
        // Immediately hide the overlay if it’s visible.
        overlay.style.opacity = 0;
        clearTimeout(inactivityTimer);
        inactivityTimer = setTimeout(() => {
          overlay.style.opacity = 1;  // fade in after inactivity
          lumonGlobe.style.opacity = 1;
        }, inactivityDuration);
      }

      // Listen for any user input (mousemove, keydown, mousedown, touchstart)
      ['mousemove', 'keydown', 'mousedown', 'touchstart'].forEach(evt => {
        document.addEventListener(evt, resetInactivityTimer, { passive: true });
      });
      resetInactivityTimer();  // start the timer on page load

      // Create and load the lumonGlobe image from the same directory.
      const lumonGlobe = new Image();
      lumonGlobe.src = "lumonGlobe.png";  // Ensure this file is in the same directory
      lumonGlobe.alt = "Lumon Globe";
      lumonGlobe.id = "lumonGlobe";
      lumonGlobe.style.position = "absolute";
      lumonGlobe.style.width = "300px";  // adjust size as needed
      lumonGlobe.style.height = "auto";
      lumonGlobe.style.filter = "drop-shadow(0 0 6px #fff)";
      
      // Append the image to the overlay so it can be animated.
      overlay.appendChild(lumonGlobe);

      // Bounce animation variables
      let posX = 0, posY = 0;
      let velocityX = 2, velocityY = 2;

      function animateGlobe() {
        const overlayRect = overlay.getBoundingClientRect();
        const globeRect = lumonGlobe.getBoundingClientRect();

        // Update position
        posX += velocityX;
        posY += velocityY;

        // Bounce off horizontal boundaries
        if (posX + globeRect.width > overlayRect.width || posX < 0) {
          velocityX = -velocityX;
          posX = Math.max(0, Math.min(posX, overlayRect.width - globeRect.width));
        }
        // Bounce off vertical boundaries
        if (posY + globeRect.height > overlayRect.height || posY < 0) {
          velocityY = -velocityY;
          posY = Math.max(0, Math.min(posY, overlayRect.height - globeRect.height));
        }

        // Apply the translation to the lumonGlobe image.
        lumonGlobe.style.transform = `translate(${posX}px, ${posY}px)`;

        requestAnimationFrame(animateGlobe);
      }

      // Start the animation once the image has loaded.
      lumonGlobe.onload = animateGlobe;
    </script>

      <script>
        // Assuming updateTotalProgressPercentForCurrentFile is defined as before.
        function updateTotalProgressPercentForCurrentFile() {
          const fileElem = document.getElementById("staticTopName");
          if (!fileElem) {
            console.error("Element with id 'staticTopName' not found.");
            return;
          }
          const currentFileName = fileElem.textContent.trim();
          if (!currentFileName) {
            console.error("No filename found in 'staticTopName'.");
            return;
          }
          
          const key = 'progress_' + currentFileName;
          const savedState = localStorage.getItem(key);
          let overallProgress = 0;
          if (savedState) {
            try {
              const state = JSON.parse(savedState);
              if (typeof state.overallProgress !== 'undefined') {
                overallProgress = state.overallProgress;
              }
              console.log(currentFileName, "progress loaded:", state);
            } catch (error) {
              console.error("Error parsing saved progress for", currentFileName, ":", error);
            }
          } else {
            console.log("No saved progress for", currentFileName);
          }
          
          const progressPercent = overallProgress;
          const progressElem = document.getElementById("totalProgressPercent");
          if (progressElem) {
            progressElem.textContent = Math.floor(progressPercent) + "%";
          } else {
            console.error("Element with id 'totalProgressPercent' not found.");
          }

          // Update the width of the progress bar element
          const progressBar = document.getElementById("progressBar");
          if (progressBar) {
            progressBar.style.width = progressPercent + "%";
          } else {
            console.error("Element with id 'progressBar' not found.");
          }
        }
        
        // Set up a MutationObserver to watch for changes in the current file name.
        window.addEventListener("DOMContentLoaded", function() {
          // Update progress once on initial load
          updateTotalProgressPercentForCurrentFile();
        
          const fileElem = document.getElementById("staticTopName");
          if (!fileElem) {
            console.error("Element with id 'staticTopName' not found.");
            return;
          }
        
          const observer = new MutationObserver((mutationsList, observer) => {
            // Whenever the text content of staticTopName changes, update the progress
            updateTotalProgressPercentForCurrentFile();
          });
          
          observer.observe(fileElem, { characterData: true, childList: true, subtree: true });
        });
      </script>
  

</body>
</html>
